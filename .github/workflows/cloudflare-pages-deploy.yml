name: Cloudflare Pages Deploy

on:
  workflow_call:
    inputs:
      # -----------------------------------------------------------------------
      # Deployment Parameters (passed from trigger)
      # -----------------------------------------------------------------------
      tag:
        description: 'Tag to deploy'
        required: true
        type: string
      environment:
        description: 'Target environment (staging, review, production, all, or empty for build-only)'
        required: false
        type: string
        default: ''
      trigger-type:
        description: 'How the workflow was triggered (tag-push or manual)'
        required: true
        type: string
      # -----------------------------------------------------------------------
      # Project Configuration
      # -----------------------------------------------------------------------
      project-name:
        description: 'Base project name in Cloudflare Pages'
        required: true
        type: string
      domain-suffix:
        description: 'Domain suffix for custom domains'
        required: false
        type: string
        default: 'plattar.com'
      # -----------------------------------------------------------------------
      # Deploy Mode Configuration
      # -----------------------------------------------------------------------
      deploy-mode:
        description: 'Deployment mode: "build" (compile first) or "static" (pre-built files)'
        required: false
        type: string
        default: 'build'
      static-source-directory:
        description: 'Source directory for static files (only used when deploy-mode is "static")'
        required: false
        type: string
        default: '.'
      # -----------------------------------------------------------------------
      # Build Configuration (only used when deploy-mode is "build")
      # -----------------------------------------------------------------------
      build-directory:
        description: 'Directory containing package.json'
        required: false
        type: string
        default: '.'
      output-directory:
        description: 'Build output path relative to build-directory'
        required: false
        type: string
        default: 'build'
      build-command:
        description: 'Build command to execute'
        required: false
        type: string
        default: 'npm run clean:build'
      node-version:
        description: 'Node.js version to use'
        required: false
        type: string
        default: 'latest'
      # -----------------------------------------------------------------------
      # Artifact Configuration
      # -----------------------------------------------------------------------
      artifact-retention-days:
        description: 'Number of days to retain build artifacts'
        required: false
        type: number
        default: 120
    secrets:
      CLOUDFLARE_API_TOKEN:
        description: 'Cloudflare API token with Pages deployment permissions'
        required: true
      CLOUDFLARE_ACCOUNT_ID:
        description: 'Cloudflare account identifier'
        required: true
    outputs:
      version:
        description: 'Deployed version number'
        value: ${{ jobs.prepare.outputs.version }}
      environment:
        description: 'Target environment(s)'
        value: ${{ jobs.prepare.outputs.environment }}
      deployment-urls:
        description: 'All deployment URLs (JSON format)'
        value: ${{ jobs.consolidate.outputs.deployment-urls }}
      primary-url:
        description: 'Primary deployment URL (production if deploying to all)'
        value: ${{ jobs.consolidate.outputs.primary-url }}

jobs:
  # ===========================================================================
  # Prepare Job - Parse parameters and determine deployment strategy
  # ===========================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      tag-name: ${{ steps.parse.outputs.tag }}
      version: ${{ steps.parse.outputs.version }}
      environment: ${{ steps.parse.outputs.environment }}
      artifact-name: ${{ steps.parse.outputs.artifact-name }}
      should-deploy: ${{ steps.parse.outputs.should-deploy }}
      deploy-mode: ${{ steps.parse.outputs.deploy-mode }}
      deploy-all: ${{ steps.parse.outputs.deploy-all }}
      environment-matrix: ${{ steps.parse.outputs.environment-matrix }}
    steps:
      - name: Parse deployment parameters
        id: parse
        run: |
          TAG_NAME="${{ inputs.tag }}"
          TRIGGER_TYPE="${{ inputs.trigger-type }}"
          DEPLOY_MODE="${{ inputs.deploy-mode }}"
          
          if [[ "$TRIGGER_TYPE" == "manual" ]]; then
            VERSION="${TAG_NAME}"
            ENVIRONMENT="${{ inputs.environment }}"
            SHOULD_DEPLOY="true"
            
            if [[ -z "$ENVIRONMENT" ]]; then
              SHOULD_DEPLOY="false"
            fi
          else
            # Parse tag to extract version and environment
            if [[ "$TAG_NAME" =~ ^(.+)-(staging|production|review|all)$ ]]; then
              VERSION="${BASH_REMATCH[1]}"
              ENVIRONMENT="${BASH_REMATCH[2]}"
              SHOULD_DEPLOY="true"
            elif [[ "$TAG_NAME" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
              VERSION="$TAG_NAME"
              ENVIRONMENT=""
              SHOULD_DEPLOY="false"
            else
              echo "ERROR: Invalid tag format: $TAG_NAME"
              echo ""
              echo "Expected formats:"
              echo "  {version}            - Build only (e.g., 1.2.0)"
              echo "  {version}-staging    - Deploy to staging"
              echo "  {version}-production - Deploy to production"
              echo "  {version}-review     - Deploy to review"
              echo "  {version}-all        - Deploy to all environments"
              exit 1
            fi
          fi
          
          # Determine if deploying to all environments
          DEPLOY_ALL="false"
          if [[ "$ENVIRONMENT" == "all" ]]; then
            DEPLOY_ALL="true"
            # Create matrix for all environments
            ENVIRONMENT_MATRIX='["production","staging","review"]'
          else
            # Single environment matrix
            ENVIRONMENT_MATRIX="[\"${ENVIRONMENT}\"]"
          fi
          
          ARTIFACT_NAME="build-${{ inputs.project-name }}-${VERSION}"
          
          echo "tag=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "artifact-name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          echo "should-deploy=${SHOULD_DEPLOY}" >> $GITHUB_OUTPUT
          echo "deploy-mode=${DEPLOY_MODE}" >> $GITHUB_OUTPUT
          echo "deploy-all=${DEPLOY_ALL}" >> $GITHUB_OUTPUT
          echo "environment-matrix=${ENVIRONMENT_MATRIX}" >> $GITHUB_OUTPUT

      - name: Generate preparation summary
        run: |
          echo "## Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Project | \`${{ inputs.project-name }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | \`${{ steps.parse.outputs.tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${{ steps.parse.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | \`${{ inputs.trigger-type }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Mode | \`${{ steps.parse.outputs.deploy-mode }}\` |" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.parse.outputs.should-deploy }}" == "true" ]]; then
            if [[ "${{ steps.parse.outputs.deploy-all }}" == "true" ]]; then
              echo "| Environments | \`production, staging, review\` |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Environment | \`${{ steps.parse.outputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
            fi
            if [[ "${{ steps.parse.outputs.deploy-mode }}" == "static" ]]; then
              echo "| Source | \`${{ inputs.static-source-directory }}\` |" >> $GITHUB_STEP_SUMMARY
              echo "| Action | Deploy Static Files |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Action | Build and Deploy |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            if [[ "${{ steps.parse.outputs.deploy-mode }}" == "static" ]]; then
              echo "| Action | Package Static Files Only |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Action | Build Only |" >> $GITHUB_STEP_SUMMARY
            fi
          fi

  # ===========================================================================
  # Build Job - Compile application (only runs when deploy-mode is "build")
  # ===========================================================================
  build:
    name: Build Application
    needs: prepare
    runs-on: ubuntu-latest
    if: needs.prepare.outputs.deploy-mode == 'build'
    outputs:
      artifact-name: ${{ needs.prepare.outputs.artifact-name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.tag-name }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}

      - name: Build application
        working-directory: ${{ inputs.build-directory }}
        run: ${{ inputs.build-command }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.prepare.outputs.artifact-name }}
          path: ${{ inputs.build-directory }}/${{ inputs.output-directory }}
          retention-days: ${{ inputs.artifact-retention-days }}
          if-no-files-found: error

  # ===========================================================================
  # Package Static Job - Package pre-built files (only runs when deploy-mode is "static")
  # ===========================================================================
  package-static:
    name: Package Static Files
    needs: prepare
    runs-on: ubuntu-latest
    if: needs.prepare.outputs.deploy-mode == 'static'
    outputs:
      artifact-name: ${{ needs.prepare.outputs.artifact-name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.tag-name }}

      - name: Verify static source directory
        run: |
          SOURCE_DIR="${{ inputs.static-source-directory }}"
          
          if [[ ! -d "$SOURCE_DIR" ]]; then
            echo "ERROR: Static source directory does not exist: $SOURCE_DIR"
            exit 1
          fi
          
          FILE_COUNT=$(find "$SOURCE_DIR" -type f | wc -l)
          
          if [[ "$FILE_COUNT" -eq 0 ]]; then
            echo "ERROR: Static source directory is empty: $SOURCE_DIR"
            exit 1
          fi
          
          echo "Found $FILE_COUNT files in $SOURCE_DIR"
          echo ""
          echo "Directory structure (first 3 levels):"
          find "$SOURCE_DIR" -maxdepth 3 -type d | head -20

      - name: Upload static artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.prepare.outputs.artifact-name }}
          path: ${{ inputs.static-source-directory }}
          retention-days: ${{ inputs.artifact-retention-days }}
          if-no-files-found: error

  # ===========================================================================
  # Deploy Job - Matrix deployment to one or more environments
  # ===========================================================================
  deploy:
    name: Deploy to ${{ matrix.environment }}
    needs: [prepare, build, package-static]
    runs-on: ubuntu-latest
    # Run if should-deploy is true AND at least one of build or package-static succeeded
    if: |
      always() &&
      needs.prepare.outputs.should-deploy == 'true' &&
      (needs.build.result == 'success' || needs.package-static.result == 'success') &&
      needs.prepare.result == 'success'
    strategy:
      # Deploy to environments in parallel
      max-parallel: 3
      fail-fast: false
      matrix:
        environment: ${{ fromJSON(needs.prepare.outputs.environment-matrix) }}
    outputs:
      deployment-url-production: ${{ steps.output.outputs.deployment-url-production }}
      deployment-url-staging: ${{ steps.output.outputs.deployment-url-staging }}
      deployment-url-review: ${{ steps.output.outputs.deployment-url-review }}
    environment:
      name: ${{ matrix.environment }}
      url: ${{ steps.config.outputs.pages-url }}
    steps:
      - name: Configure deployment parameters
        id: config
        run: |
          PROJECT_NAME="${{ inputs.project-name }}"
          ENVIRONMENT="${{ matrix.environment }}"
          DOMAIN_SUFFIX="${{ inputs.domain-suffix }}"
          
          if [[ "$ENVIRONMENT" == "production" ]]; then
            CF_PROJECT="${PROJECT_NAME}"
            CUSTOM_DOMAIN="${PROJECT_NAME}.${DOMAIN_SUFFIX}"
          else
            CF_PROJECT="${PROJECT_NAME}-${ENVIRONMENT}"
            CUSTOM_DOMAIN="${PROJECT_NAME}-${ENVIRONMENT}.${DOMAIN_SUFFIX}"
          fi
          
          echo "cloudflare-project=${CF_PROJECT}" >> $GITHUB_OUTPUT
          echo "custom-domain=${CUSTOM_DOMAIN}" >> $GITHUB_OUTPUT
          echo "pages-url=https://${CF_PROJECT}.pages.dev" >> $GITHUB_OUTPUT

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.prepare.outputs.artifact-name }}
          path: ./deploy

      - name: Deploy version branch
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy ./deploy --project-name ${{ steps.config.outputs.cloudflare-project }} --branch ${{ needs.prepare.outputs.version }}

      - name: Deploy production branch
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy ./deploy --project-name ${{ steps.config.outputs.cloudflare-project }} --branch main

      - name: Calculate URLs
        id: urls
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          CF_PROJECT="${{ steps.config.outputs.cloudflare-project }}"
          echo "version-url=https://${VERSION}.${CF_PROJECT}.pages.dev" >> $GITHUB_OUTPUT

      - name: Set job outputs
        id: output
        run: |
          ENVIRONMENT="${{ matrix.environment }}"
          PAGES_URL="${{ steps.config.outputs.pages-url }}"
          
          # Set environment-specific output
          echo "deployment-url-${ENVIRONMENT}=${PAGES_URL}" >> $GITHUB_OUTPUT

      - name: Generate deployment summary
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          CF_PROJECT="${{ steps.config.outputs.cloudflare-project }}"
          PAGES_URL="${{ steps.config.outputs.pages-url }}"
          VERSION_URL="${{ steps.urls.outputs.version-url }}"
          CUSTOM_DOMAIN="${{ steps.config.outputs.custom-domain }}"
          DEPLOY_MODE="${{ needs.prepare.outputs.deploy-mode }}"
          ENVIRONMENT="${{ matrix.environment }}"
          
          echo "## Deployment Complete: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${ENVIRONMENT}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Mode | \`${DEPLOY_MODE}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Cloudflare Project | \`${CF_PROJECT}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment URLs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Type | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| Custom Domain | [${CUSTOM_DOMAIN}](https://${CUSTOM_DOMAIN}) |" >> $GITHUB_STEP_SUMMARY
          echo "| Pages URL | [${CF_PROJECT}.pages.dev](${PAGES_URL}) |" >> $GITHUB_STEP_SUMMARY
          echo "| Version URL | [${VERSION}.${CF_PROJECT}.pages.dev](${VERSION_URL}) |" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Consolidate Job - Gather all deployment URLs and update release notes
  # ===========================================================================
  consolidate:
    name: Consolidate Results
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: always() && needs.deploy.result == 'success'
    outputs:
      deployment-urls: ${{ steps.gather.outputs.deployment-urls }}
      primary-url: ${{ steps.gather.outputs.primary-url }}
    steps:
      - name: Gather deployment URLs
        id: gather
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          PROJECT_NAME="${{ inputs.project-name }}"
          DOMAIN_SUFFIX="${{ inputs.domain-suffix }}"
          DEPLOY_ALL="${{ needs.prepare.outputs.deploy-all }}"
          ENVIRONMENT="${{ needs.prepare.outputs.environment }}"
          
          # Build JSON with all deployment URLs
          if [[ "$DEPLOY_ALL" == "true" ]]; then
            # All environments deployed
            DEPLOYMENT_URLS=$(cat <<EOF
          {
            "production": {
              "custom": "https://${PROJECT_NAME}.${DOMAIN_SUFFIX}",
              "pages": "https://${PROJECT_NAME}.pages.dev",
              "version": "https://${VERSION}.${PROJECT_NAME}.pages.dev"
            },
            "staging": {
              "custom": "https://${PROJECT_NAME}-staging.${DOMAIN_SUFFIX}",
              "pages": "https://${PROJECT_NAME}-staging.pages.dev",
              "version": "https://${VERSION}.${PROJECT_NAME}-staging.pages.dev"
            },
            "review": {
              "custom": "https://${PROJECT_NAME}-review.${DOMAIN_SUFFIX}",
              "pages": "https://${PROJECT_NAME}-review.pages.dev",
              "version": "https://${VERSION}.${PROJECT_NAME}-review.pages.dev"
            }
          }
          EOF
          )
            PRIMARY_URL="https://${PROJECT_NAME}.${DOMAIN_SUFFIX}"
          else
            # Single environment deployed
            if [[ "$ENVIRONMENT" == "production" ]]; then
              CF_PROJECT="${PROJECT_NAME}"
              CUSTOM_DOMAIN="${PROJECT_NAME}.${DOMAIN_SUFFIX}"
            else
              CF_PROJECT="${PROJECT_NAME}-${ENVIRONMENT}"
              CUSTOM_DOMAIN="${PROJECT_NAME}-${ENVIRONMENT}.${DOMAIN_SUFFIX}"
            fi
            
            DEPLOYMENT_URLS=$(cat <<EOF
          {
            "${ENVIRONMENT}": {
              "custom": "https://${CUSTOM_DOMAIN}",
              "pages": "https://${CF_PROJECT}.pages.dev",
              "version": "https://${VERSION}.${CF_PROJECT}.pages.dev"
            }
          }
          EOF
          )
            PRIMARY_URL="https://${CUSTOM_DOMAIN}"
          fi
          
          # Compact JSON (remove newlines)
          DEPLOYMENT_URLS_COMPACT=$(echo "$DEPLOYMENT_URLS" | jq -c .)
          
          echo "deployment-urls=${DEPLOYMENT_URLS_COMPACT}" >> $GITHUB_OUTPUT
          echo "primary-url=${PRIMARY_URL}" >> $GITHUB_OUTPUT

      - name: Generate consolidated summary
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          DEPLOY_ALL="${{ needs.prepare.outputs.deploy-all }}"
          DEPLOYMENT_URLS='${{ steps.gather.outputs.deployment-urls }}'
          
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`${VERSION}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "$DEPLOY_ALL" == "true" ]]; then
            echo "### All Environments Deployed âœ…" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Production
            PROD_CUSTOM=$(echo "$DEPLOYMENT_URLS" | jq -r '.production.custom')
            PROD_PAGES=$(echo "$DEPLOYMENT_URLS" | jq -r '.production.pages')
            echo "#### Production" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸŒ [${PROD_CUSTOM}](${PROD_CUSTOM})" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ“„ [${PROD_PAGES}](${PROD_PAGES})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Staging
            STAGING_CUSTOM=$(echo "$DEPLOYMENT_URLS" | jq -r '.staging.custom')
            STAGING_PAGES=$(echo "$DEPLOYMENT_URLS" | jq -r '.staging.pages')
            echo "#### Staging" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸŒ [${STAGING_CUSTOM}](${STAGING_CUSTOM})" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ“„ [${STAGING_PAGES}](${STAGING_PAGES})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Review
            REVIEW_CUSTOM=$(echo "$DEPLOYMENT_URLS" | jq -r '.review.custom')
            REVIEW_PAGES=$(echo "$DEPLOYMENT_URLS" | jq -r '.review.pages')
            echo "#### Review" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸŒ [${REVIEW_CUSTOM}](${REVIEW_CUSTOM})" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ“„ [${REVIEW_PAGES}](${REVIEW_PAGES})" >> $GITHUB_STEP_SUMMARY
          else
            ENVIRONMENT="${{ needs.prepare.outputs.environment }}"
            ENV_CUSTOM=$(echo "$DEPLOYMENT_URLS" | jq -r ".${ENVIRONMENT}.custom")
            ENV_PAGES=$(echo "$DEPLOYMENT_URLS" | jq -r ".${ENVIRONMENT}.pages")
            
            echo "### ${ENVIRONMENT^} Deployed âœ…" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸŒ [${ENV_CUSTOM}](${ENV_CUSTOM})" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ“„ [${ENV_PAGES}](${ENV_PAGES})" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Update GitHub Release
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.prepare.outputs.version }}';
            const deployAll = '${{ needs.prepare.outputs.deploy-all }}' === 'true';
            const environment = '${{ needs.prepare.outputs.environment }}';
            const deploymentUrls = JSON.parse('${{ steps.gather.outputs.deployment-urls }}');
            const deploymentType = '${{ inputs.trigger-type }}' === 'manual' ? 'Manual' : 'Automatic';
            const deployMode = '${{ needs.prepare.outputs.deploy-mode }}';
            const timestamp = new Date().toISOString().split('T')[0];
            
            try {
              let release;
              
              try {
                release = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: version
                });
              } catch (error) {
                if (error.status === 404) {
                  const isPrerelease = /-(alpha|beta|rc|preview)/i.test(version);
                  release = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: version,
                    name: `Release ${version}`,
                    body: `## Release ${version}\n\n### Deployments\n`,
                    draft: false,
                    prerelease: isPrerelease
                  });
                } else {
                  throw error;
                }
              }
              
              const currentBody = release.data.body || '';
              const modeLabel = deployMode === 'static' ? ' (Static)' : '';
              let deploymentEntries = [];
              
              if (deployAll) {
                // Create entries for all environments
                const environments = ['production', 'staging', 'review'];
                for (const env of environments) {
                  const urls = deploymentUrls[env];
                  const entry = `- **${env}**${modeLabel} (${deploymentType}): [${urls.custom.replace('https://', '')}](${urls.custom}) | [Pages](${urls.pages}) | [Version](${urls.version}) - ${timestamp}`;
                  deploymentEntries.push(entry);
                }
              } else {
                // Single environment entry
                const urls = deploymentUrls[environment];
                const entry = `- **${environment}**${modeLabel} (${deploymentType}): [${urls.custom.replace('https://', '')}](${urls.custom}) | [Pages](${urls.pages}) | [Version](${urls.version}) - ${timestamp}`;
                deploymentEntries.push(entry);
              }
              
              let updatedBody = currentBody;
              
              // Update or add each deployment entry
              for (const entry of deploymentEntries) {
                const envMatch = entry.match(/\*\*(\w+)\*\*/);
                if (envMatch) {
                  const env = envMatch[1];
                  const envPattern = new RegExp(`- \\*\\*${env}\\*\\*.*`, 'g');
                  
                  if (envPattern.test(updatedBody)) {
                    updatedBody = updatedBody.replace(envPattern, entry);
                  } else if (updatedBody.includes('### Deployments')) {
                    updatedBody = updatedBody.replace('### Deployments\n', `### Deployments\n${entry}\n`);
                  } else {
                    updatedBody = updatedBody + `\n\n### Deployments\n${entry}\n`;
                  }
                }
              }
              
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                body: updatedBody
              });
              
              if (deployAll) {
                core.info(`Updated release notes for version ${version} (all environments)`);
              } else {
                core.info(`Updated release notes for version ${version} (${environment})`);
              }
            } catch (error) {
              core.warning(`Could not update release notes: ${error.message}`);
            }