name: Cloudflare Pages Deploy

on:
  workflow_call:
    inputs:
      # -----------------------------------------------------------------------
      # Deployment Parameters (passed from trigger)
      # -----------------------------------------------------------------------
      tag:
        description: 'Tag to deploy'
        required: true
        type: string
      environment:
        description: 'Target environment (staging, review, production, all, or empty for build-only)'
        required: false
        type: string
        default: ''
      trigger-type:
        description: 'How the workflow was triggered (tag-push or manual)'
        required: true
        type: string
      # -----------------------------------------------------------------------
      # Project Configuration
      # -----------------------------------------------------------------------
      project-name:
        description: 'Base project name in Cloudflare Pages'
        required: true
        type: string
      domain-suffix:
        description: 'Domain suffix for custom domains'
        required: false
        type: string
        default: 'plattar.com'
      # -----------------------------------------------------------------------
      # Deploy Mode Configuration
      # -----------------------------------------------------------------------
      deploy-mode:
        description: 'Deployment mode: "build" (compile first) or "static" (pre-built files)'
        required: false
        type: string
        default: 'build'
      static-source-directory:
        description: 'Source directory for static files (only used when deploy-mode is "static")'
        required: false
        type: string
        default: '.'
      # -----------------------------------------------------------------------
      # Build Configuration (only used when deploy-mode is "build")
      # -----------------------------------------------------------------------
      build-directory:
        description: 'Directory containing package.json'
        required: false
        type: string
        default: '.'
      output-directory:
        description: 'Build output path relative to build-directory'
        required: false
        type: string
        default: 'build'
      build-command:
        description: 'Build command to execute'
        required: false
        type: string
        default: 'npm run clean:build'
      node-version:
        description: 'Node.js version to use'
        required: false
        type: string
        default: 'latest'
      # -----------------------------------------------------------------------
      # 404 Page Configuration
      # -----------------------------------------------------------------------
      generate-404-page:
        description: 'Generate a default 404.html page if one does not exist'
        required: false
        type: boolean
        default: true
      # -----------------------------------------------------------------------
      # Artifact Configuration
      # -----------------------------------------------------------------------
      artifact-retention-days:
        description: 'Number of days to retain build artifacts'
        required: false
        type: number
        default: 120
    secrets:
      CLOUDFLARE_API_TOKEN:
        description: 'Cloudflare API token with Pages deployment permissions'
        required: true
      CLOUDFLARE_ACCOUNT_ID:
        description: 'Cloudflare account identifier'
        required: true
    outputs:
      version:
        description: 'Deployed version number'
        value: ${{ jobs.prepare.outputs.version }}
      environment:
        description: 'Target environment(s)'
        value: ${{ jobs.prepare.outputs.environment }}
      deployment-urls:
        description: 'All deployment URLs (JSON format)'
        value: ${{ jobs.consolidate.outputs.deployment-urls }}
      primary-url:
        description: 'Primary deployment URL (production if deploying to all)'
        value: ${{ jobs.consolidate.outputs.primary-url }}

jobs:
  # ===========================================================================
  # Prepare Job - Parse parameters and determine deployment strategy
  # ===========================================================================
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      tag-name: ${{ steps.parse.outputs.tag }}
      version: ${{ steps.parse.outputs.version }}
      environment: ${{ steps.parse.outputs.environment }}
      artifact-name: ${{ steps.parse.outputs.artifact-name }}
      should-deploy: ${{ steps.parse.outputs.should-deploy }}
      deploy-mode: ${{ steps.parse.outputs.deploy-mode }}
      deploy-all: ${{ steps.parse.outputs.deploy-all }}
      environment-matrix: ${{ steps.parse.outputs.environment-matrix }}
    steps:
      - name: Parse deployment parameters
        id: parse
        run: |
          TAG_NAME="${{ inputs.tag }}"
          TRIGGER_TYPE="${{ inputs.trigger-type }}"
          DEPLOY_MODE="${{ inputs.deploy-mode }}"
          
          echo "::group::Parsing Deployment Configuration"
          echo "Tag: ${TAG_NAME}"
          echo "Trigger Type: ${TRIGGER_TYPE}"
          echo "Deploy Mode: ${DEPLOY_MODE}"
          echo "::endgroup::"
          
          if [[ "$TRIGGER_TYPE" == "manual" ]]; then
            VERSION="${TAG_NAME}"
            ENVIRONMENT="${{ inputs.environment }}"
            SHOULD_DEPLOY="true"
            
            if [[ -z "$ENVIRONMENT" ]]; then
              SHOULD_DEPLOY="false"
            fi
          else
            # Parse tag to extract version and environment
            if [[ "$TAG_NAME" =~ ^([0-9]+\.[0-9]+\.[0-9]+.*?)-(staging|production|review|all)$ ]]; then
              VERSION="${BASH_REMATCH[1]}"
              ENVIRONMENT="${BASH_REMATCH[2]}"
              SHOULD_DEPLOY="true"
            elif [[ "$TAG_NAME" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
              VERSION="$TAG_NAME"
              ENVIRONMENT=""
              SHOULD_DEPLOY="false"
            else
              echo "::error title=Invalid Tag Format::Tag '${TAG_NAME}' does not match expected format"
              echo ""
              echo "Expected tag formats:"
              echo "  {version}            - Build only (example: 1.2.0)"
              echo "  {version}-staging    - Deploy to staging environment"
              echo "  {version}-production - Deploy to production environment"
              echo "  {version}-review     - Deploy to review environment"
              echo "  {version}-all        - Deploy to all environments"
              exit 1
            fi
          fi
          
          # Determine if deploying to all environments
          DEPLOY_ALL="false"
          if [[ "$ENVIRONMENT" == "all" ]]; then
            DEPLOY_ALL="true"
            ENVIRONMENT_MATRIX='["production","staging","review"]'
          else
            ENVIRONMENT_MATRIX="[\"${ENVIRONMENT}\"]"
          fi
          
          ARTIFACT_NAME="build-${{ inputs.project-name }}-${VERSION}"
          
          echo "::group::Configuration Results"
          echo "Version: ${VERSION}"
          echo "Environment: ${ENVIRONMENT:-none}"
          echo "Should Deploy: ${SHOULD_DEPLOY}"
          echo "Deploy All: ${DEPLOY_ALL}"
          echo "Artifact Name: ${ARTIFACT_NAME}"
          echo "::endgroup::"
          
          echo "tag=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "artifact-name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          echo "should-deploy=${SHOULD_DEPLOY}" >> $GITHUB_OUTPUT
          echo "deploy-mode=${DEPLOY_MODE}" >> $GITHUB_OUTPUT
          echo "deploy-all=${DEPLOY_ALL}" >> $GITHUB_OUTPUT
          echo "environment-matrix=${ENVIRONMENT_MATRIX}" >> $GITHUB_OUTPUT

      - name: Generate deployment summary
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## Deployment Configuration
          
          ### Configuration Parameters
          
          | Parameter | Value |
          |-----------|-------|
          | Project | `${{ inputs.project-name }}` |
          | Tag | `${{ steps.parse.outputs.tag }}` |
          | Version | `${{ steps.parse.outputs.version }}` |
          | Trigger Method | `${{ inputs.trigger-type }}` |
          | Deploy Mode | `${{ steps.parse.outputs.deploy-mode }}` |
          EOF
          
          if [[ "${{ steps.parse.outputs.should-deploy }}" == "true" ]]; then
            if [[ "${{ steps.parse.outputs.deploy-all }}" == "true" ]]; then
              echo "| Target Environments | \`production\`, \`staging\`, \`review\` |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Target Environment | \`${{ steps.parse.outputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Deployment Action" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [[ "${{ steps.parse.outputs.deploy-mode }}" == "static" ]]; then
              echo "**Operation**: Deploy static files from \`${{ inputs.static-source-directory }}\`" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Operation**: Build application and deploy artifacts" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Build Action" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [[ "${{ steps.parse.outputs.deploy-mode }}" == "static" ]]; then
              echo "**Operation**: Package static files only (no deployment)" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Operation**: Build application only (no deployment)" >> $GITHUB_STEP_SUMMARY
            fi
          fi

  # ===========================================================================
  # Build Job - Compile application (only runs when deploy-mode is "build")
  # ===========================================================================
  build:
    name: Build Application
    needs: prepare
    runs-on: ubuntu-latest
    if: needs.prepare.outputs.deploy-mode == 'build'
    outputs:
      artifact-name: ${{ needs.prepare.outputs.artifact-name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.tag-name }}

      - name: Setup Node.js environment
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}

      - name: Install dependencies
        working-directory: ${{ inputs.build-directory }}
        run: |
          echo "::group::Installing Node.js dependencies"
          ${{inputs.build-command}}
          echo "::endgroup::"

      - name: Execute build command
        working-directory: ${{ inputs.build-directory }}
        run: |
          echo "::group::Building application"
          echo "Build Command: ${{ inputs.build-command }}"
          echo "Output Directory: ${{ inputs.output-directory }}"
          ${{ inputs.build-command }}
          echo "::endgroup::"

      - name: Verify build output
        working-directory: ${{ inputs.build-directory }}
        run: |
          OUTPUT_DIR="${{ inputs.output-directory }}"
          
          if [[ ! -d "$OUTPUT_DIR" ]]; then
            echo "::error title=Build Output Missing::Expected build output directory not found: ${OUTPUT_DIR}"
            echo "::group::Available directories"
            ls -la
            echo "::endgroup::"
            exit 1
          fi
          
          FILE_COUNT=$(find "$OUTPUT_DIR" -type f | wc -l)
          
          if [[ "$FILE_COUNT" -eq 0 ]]; then
            echo "::error title=Empty Build Output::Build output directory contains no files: ${OUTPUT_DIR}"
            exit 1
          fi
          
          OUTPUT_SIZE=$(du -sh "$OUTPUT_DIR" | cut -f1)
          
          echo "::group::Build Verification Results"
          echo "Output Directory: ${OUTPUT_DIR}"
          echo "File Count: ${FILE_COUNT}"
          echo "Total Size: ${OUTPUT_SIZE}"
          echo "::endgroup::"
          
          echo "::notice title=Build Complete::Successfully built ${FILE_COUNT} files (${OUTPUT_SIZE})"

      - name: Generate 404 page if missing
        if: inputs.generate-404-page == true
        working-directory: ${{ inputs.build-directory }}/${{ inputs.output-directory }}
        run: |
          if [[ ! -f "404.html" ]]; then
            echo "::notice title=Generating 404 Page::No 404.html found, creating default page"
            
            cat > 404.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>404 - Page Not Found</title>
              <style>
                  @import url('https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;600;700&display=swap');
                  
                  * {
                      margin: 0;
                      padding: 0;
                      box-sizing: border-box;
                  }
                  
                  body {
                      font-family: "Figtree", sans-serif;
                      background-color: #f7f7f7;
                      color: #221f1f;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      min-height: 100vh;
                      padding: 20px;
                      line-height: 1.6;
                  }
                  
                  .container {
                      text-align: center;
                      max-width: 600px;
                  }
                  
                  .error-code {
                      font-size: 120px;
                      font-weight: 700;
                      color: #221f1f;
                      margin-bottom: 20px;
                      line-height: 1;
                      letter-spacing: -2px;
                  }
                  
                  h1 {
                      font-size: 32px;
                      font-weight: 600;
                      margin-bottom: 16px;
                      color: #221f1f;
                  }
                  
                  p {
                      font-size: 18px;
                      color: #221f1f;
                      opacity: 0.8;
                      margin-bottom: 0;
                  }
                  
                  .divider {
                      width: 60px;
                      height: 3px;
                      background-color: #221f1f;
                      margin: 30px auto;
                      opacity: 0.3;
                  }
                  
                  @media (max-width: 768px) {
                      .error-code {
                          font-size: 80px;
                      }
                      
                      h1 {
                          font-size: 24px;
                      }
                      
                      p {
                          font-size: 16px;
                      }
                  }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="error-code">404</div>
                  <h1>Page Not Found</h1>
                  <div class="divider"></div>
                  <p>Sorry, the page you are looking for doesn't exist or has been moved.</p>
              </div>
          </body>
          </html>
          EOF
            
            echo "::notice title=404 Page Created::Default 404.html has been generated"
          else
            echo "::notice title=404 Page Exists::Using existing 404.html from build output"
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.prepare.outputs.artifact-name }}
          path: ${{ inputs.build-directory }}/${{ inputs.output-directory }}
          retention-days: ${{ inputs.artifact-retention-days }}
          if-no-files-found: error
          compression-level: 6

      - name: Generate build summary
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## Build Results
          
          ### Build Information
          
          | Metric | Value |
          |--------|-------|
          | Version | `${{ needs.prepare.outputs.version }}` |
          | Node Version | `${{ inputs.node-version }}` |
          | Build Command | `${{ inputs.build-command }}` |
          | Output Directory | `${{ inputs.output-directory }}` |
          | Artifact Name | `${{ needs.prepare.outputs.artifact-name }}` |
          | Retention Period | `${{ inputs.artifact-retention-days }}` days |
          | 404 Page Generation | `${{ inputs.generate-404-page }}` |
          
          **Status**: Build completed successfully
          EOF

  # ===========================================================================
  # Package Static Job - Package pre-built files (only runs when deploy-mode is "static")
  # ===========================================================================
  package-static:
    name: Package Static Files
    needs: prepare
    runs-on: ubuntu-latest
    if: needs.prepare.outputs.deploy-mode == 'static'
    outputs:
      artifact-name: ${{ needs.prepare.outputs.artifact-name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.tag-name }}

      - name: Verify static source directory
        run: |
          SOURCE_DIR="${{ inputs.static-source-directory }}"
          
          echo "::group::Verifying Static Source Directory"
          echo "Source Directory: ${SOURCE_DIR}"
          
          if [[ ! -d "$SOURCE_DIR" ]]; then
            echo "::endgroup::"
            echo "::error title=Directory Not Found::Static source directory does not exist: ${SOURCE_DIR}"
            echo ""
            echo "Available directories in repository root:"
            ls -la
            exit 1
          fi
          
          FILE_COUNT=$(find "$SOURCE_DIR" -type f | wc -l)
          
          if [[ "$FILE_COUNT" -eq 0 ]]; then
            echo "::endgroup::"
            echo "::error title=Empty Directory::Static source directory contains no files: ${SOURCE_DIR}"
            exit 1
          fi
          
          SOURCE_SIZE=$(du -sh "$SOURCE_DIR" | cut -f1)
          
          echo "File Count: ${FILE_COUNT}"
          echo "Total Size: ${SOURCE_SIZE}"
          echo "::endgroup::"
          
          echo "::notice title=Verification Complete::Found ${FILE_COUNT} files (${SOURCE_SIZE}) in ${SOURCE_DIR}"

      - name: Generate 404 page if missing
        if: inputs.generate-404-page == true
        working-directory: ${{ inputs.static-source-directory }}
        run: |
          if [[ ! -f "404.html" ]]; then
            echo "::notice title=Generating 404 Page::No 404.html found, creating default page"
            
            cat > 404.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>404 - Page Not Found</title>
              <style>
                  @import url('https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;600;700&display=swap');
                  
                  * {
                      margin: 0;
                      padding: 0;
                      box-sizing: border-box;
                  }
                  
                  body {
                      font-family: "Figtree", sans-serif;
                      background-color: #f7f7f7;
                      color: #221f1f;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      min-height: 100vh;
                      padding: 20px;
                      line-height: 1.6;
                  }
                  
                  .container {
                      text-align: center;
                      max-width: 600px;
                  }
                  
                  .error-code {
                      font-size: 120px;
                      font-weight: 700;
                      color: #221f1f;
                      margin-bottom: 20px;
                      line-height: 1;
                      letter-spacing: -2px;
                  }
                  
                  h1 {
                      font-size: 32px;
                      font-weight: 600;
                      margin-bottom: 16px;
                      color: #221f1f;
                  }
                  
                  p {
                      font-size: 18px;
                      color: #221f1f;
                      opacity: 0.8;
                      margin-bottom: 0;
                  }
                  
                  .divider {
                      width: 60px;
                      height: 3px;
                      background-color: #221f1f;
                      margin: 30px auto;
                      opacity: 0.3;
                  }
                  
                  @media (max-width: 768px) {
                      .error-code {
                          font-size: 80px;
                      }
                      
                      h1 {
                          font-size: 24px;
                      }
                      
                      p {
                          font-size: 16px;
                      }
                  }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="error-code">404</div>
                  <h1>Page Not Found</h1>
                  <div class="divider"></div>
                  <p>Sorry, the page you are looking for doesn't exist or has been moved.</p>
              </div>
          </body>
          </html>
          EOF
            
            echo "::notice title=404 Page Created::Default 404.html has been generated"
          else
            echo "::notice title=404 Page Exists::Using existing 404.html from static source"
          fi

      - name: Upload static artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ needs.prepare.outputs.artifact-name }}
          path: ${{ inputs.static-source-directory }}
          retention-days: ${{ inputs.artifact-retention-days }}
          if-no-files-found: error
          compression-level: 6

      - name: Generate packaging summary
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## Static Files Packaged
          
          ### Package Information
          
          | Metric | Value |
          |--------|-------|
          | Version | `${{ needs.prepare.outputs.version }}` |
          | Source Directory | `${{ inputs.static-source-directory }}` |
          | Artifact Name | `${{ needs.prepare.outputs.artifact-name }}` |
          | Retention Period | `${{ inputs.artifact-retention-days }}` days |
          | 404 Page Generation | `${{ inputs.generate-404-page }}` |
          
          **Status**: Static files packaged successfully
          EOF

  # ===========================================================================
  # Deploy Job - Matrix deployment to one or more environments
  # ===========================================================================
  deploy:
    name: Deploy to ${{ matrix.environment }}
    needs: [prepare, build, package-static]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: |
      always() &&
      needs.prepare.outputs.should-deploy == 'true' &&
      (needs.build.result == 'success' || needs.package-static.result == 'success') &&
      needs.prepare.result == 'success'
    strategy:
      max-parallel: 3
      fail-fast: false
      matrix:
        environment: ${{ fromJSON(needs.prepare.outputs.environment-matrix) }}
    environment:
      name: ${{ matrix.environment }}
      url: ${{ steps.config.outputs.pages-url }}
    steps:
      - name: Configure deployment parameters
        id: config
        run: |
          PROJECT_NAME="${{ inputs.project-name }}"
          ENVIRONMENT="${{ matrix.environment }}"
          DOMAIN_SUFFIX="${{ inputs.domain-suffix }}"
          
          echo "::group::Deployment Configuration"
          echo "Environment: ${ENVIRONMENT}"
          echo "Project Name: ${PROJECT_NAME}"
          echo "Domain Suffix: ${DOMAIN_SUFFIX}"
          
          if [[ "$ENVIRONMENT" == "production" ]]; then
            CF_PROJECT="${PROJECT_NAME}"
            CUSTOM_DOMAIN="${PROJECT_NAME}.${DOMAIN_SUFFIX}"
          else
            CF_PROJECT="${PROJECT_NAME}-${ENVIRONMENT}"
            CUSTOM_DOMAIN="${PROJECT_NAME}-${ENVIRONMENT}.${DOMAIN_SUFFIX}"
          fi
          
          PAGES_URL="https://${CF_PROJECT}.pages.dev"
          
          echo "Cloudflare Project: ${CF_PROJECT}"
          echo "Custom Domain: ${CUSTOM_DOMAIN}"
          echo "Pages URL: ${PAGES_URL}"
          echo "::endgroup::"
          
          echo "cloudflare-project=${CF_PROJECT}" >> $GITHUB_OUTPUT
          echo "custom-domain=${CUSTOM_DOMAIN}" >> $GITHUB_OUTPUT
          echo "pages-url=${PAGES_URL}" >> $GITHUB_OUTPUT

      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.prepare.outputs.artifact-name }}
          path: ./deploy

      - name: Verify artifacts
        run: |
          echo "::group::Artifact Verification"
          FILE_COUNT=$(find ./deploy -type f | wc -l)
          DEPLOY_SIZE=$(du -sh ./deploy | cut -f1)
          
          echo "Files to Deploy: ${FILE_COUNT}"
          echo "Total Size: ${DEPLOY_SIZE}"
          echo "::endgroup::"
          
          if [[ "$FILE_COUNT" -eq 0 ]]; then
            echo "::error title=No Files to Deploy::Artifact contains no files"
            exit 1
          fi
          
          echo "::notice title=Artifacts Ready::Prepared ${FILE_COUNT} files (${DEPLOY_SIZE}) for deployment"

      - name: Deploy version branch
        id: deploy-version
        timeout-minutes: 5
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy ./deploy --project-name ${{ steps.config.outputs.cloudflare-project }} --branch ${{ needs.prepare.outputs.version }}

      - name: Deploy production branch
        id: deploy-main
        timeout-minutes: 5
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          command: pages deploy ./deploy --project-name ${{ steps.config.outputs.cloudflare-project }} --branch main

      - name: Calculate deployment URLs
        id: urls
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          CF_PROJECT="${{ steps.config.outputs.cloudflare-project }}"
          VERSION_URL="https://${VERSION}.${CF_PROJECT}.pages.dev"
          
          echo "version-url=${VERSION_URL}" >> $GITHUB_OUTPUT

      - name: Save deployment metadata
        run: |
          mkdir -p deployment-results
          cat > deployment-results/${{ matrix.environment }}.json << EOF
          {
            "environment": "${{ matrix.environment }}",
            "version": "${{ needs.prepare.outputs.version }}",
            "cloudflare_project": "${{ steps.config.outputs.cloudflare-project }}",
            "custom_domain": "${{ steps.config.outputs.custom-domain }}",
            "pages_url": "${{ steps.config.outputs.pages-url }}",
            "version_url": "${{ steps.urls.outputs.version-url }}",
            "deployed_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          }
          EOF

      - name: Upload deployment metadata
        uses: actions/upload-artifact@v4
        with:
          name: deployment-metadata-${{ matrix.environment }}
          path: deployment-results/
          retention-days: 90

      - name: Generate deployment summary
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          CF_PROJECT="${{ steps.config.outputs.cloudflare-project }}"
          PAGES_URL="${{ steps.config.outputs.pages-url }}"
          VERSION_URL="${{ steps.urls.outputs.version-url }}"
          CUSTOM_DOMAIN="${{ steps.config.outputs.custom-domain }}"
          DEPLOY_MODE="${{ needs.prepare.outputs.deploy-mode }}"
          ENVIRONMENT="${{ matrix.environment }}"
          
          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## Deployment Complete: ${ENVIRONMENT}
          
          ### Deployment Details
          
          | Parameter | Value |
          |-----------|-------|
          | Version | \`${VERSION}\` |
          | Environment | \`${ENVIRONMENT}\` |
          | Deploy Mode | \`${DEPLOY_MODE}\` |
          | Cloudflare Project | \`${CF_PROJECT}\` |
          
          ### Deployment URLs
          
          | Type | URL |
          |------|-----|
          | Custom Domain | [\`${CUSTOM_DOMAIN}\`](https://${CUSTOM_DOMAIN}) |
          | Pages URL | [\`${CF_PROJECT}.pages.dev\`](${PAGES_URL}) |
          | Version URL | [\`${VERSION}.${CF_PROJECT}.pages.dev\`](${VERSION_URL}) |
          
          **Status**: Deployment completed successfully at $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          EOF

  # ===========================================================================
  # Consolidate Job - Gather all deployment URLs and update release notes
  # ===========================================================================
  consolidate:
    name: Consolidate Results
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: always() && needs.deploy.result == 'success'
    outputs:
      deployment-urls: ${{ steps.gather.outputs.deployment-urls }}
      primary-url: ${{ steps.gather.outputs.primary-url }}
    steps:
      - name: Download all deployment metadata
        uses: actions/download-artifact@v4
        with:
          pattern: deployment-metadata-*
          path: deployment-results
          merge-multiple: true

      - name: Gather deployment information
        id: gather
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          PROJECT_NAME="${{ inputs.project-name }}"
          DOMAIN_SUFFIX="${{ inputs.domain-suffix }}"
          DEPLOY_ALL="${{ needs.prepare.outputs.deploy-all }}"
          ENVIRONMENT="${{ needs.prepare.outputs.environment }}"
          
          echo "::group::Consolidating Deployment Information"
          
          # Build JSON with all deployment URLs
          if [[ "$DEPLOY_ALL" == "true" ]]; then
            DEPLOYMENT_URLS=$(cat <<EOF
          {
            "production": {
              "custom": "https://${PROJECT_NAME}.${DOMAIN_SUFFIX}",
              "pages": "https://${PROJECT_NAME}.pages.dev",
              "version": "https://${VERSION}.${PROJECT_NAME}.pages.dev"
            },
            "staging": {
              "custom": "https://${PROJECT_NAME}-staging.${DOMAIN_SUFFIX}",
              "pages": "https://${PROJECT_NAME}-staging.pages.dev",
              "version": "https://${VERSION}.${PROJECT_NAME}-staging.pages.dev"
            },
            "review": {
              "custom": "https://${PROJECT_NAME}-review.${DOMAIN_SUFFIX}",
              "pages": "https://${PROJECT_NAME}-review.pages.dev",
              "version": "https://${VERSION}.${PROJECT_NAME}-review.pages.dev"
            }
          }
          EOF
          )
            PRIMARY_URL="https://${PROJECT_NAME}.${DOMAIN_SUFFIX}"
            echo "Deployment Scope: All Environments"
          else
            if [[ "$ENVIRONMENT" == "production" ]]; then
              CF_PROJECT="${PROJECT_NAME}"
              CUSTOM_DOMAIN="${PROJECT_NAME}.${DOMAIN_SUFFIX}"
            else
              CF_PROJECT="${PROJECT_NAME}-${ENVIRONMENT}"
              CUSTOM_DOMAIN="${PROJECT_NAME}-${ENVIRONMENT}.${DOMAIN_SUFFIX}"
            fi
            
            DEPLOYMENT_URLS=$(cat <<EOF
          {
            "${ENVIRONMENT}": {
              "custom": "https://${CUSTOM_DOMAIN}",
              "pages": "https://${CF_PROJECT}.pages.dev",
              "version": "https://${VERSION}.${CF_PROJECT}.pages.dev"
            }
          }
          EOF
          )
            PRIMARY_URL="https://${CUSTOM_DOMAIN}"
            echo "Deployment Scope: ${ENVIRONMENT}"
          fi
          
          # Compact JSON
          DEPLOYMENT_URLS_COMPACT=$(echo "$DEPLOYMENT_URLS" | jq -c .)
          
          echo "Primary URL: ${PRIMARY_URL}"
          echo "::endgroup::"
          
          echo "deployment-urls=${DEPLOYMENT_URLS_COMPACT}" >> $GITHUB_OUTPUT
          echo "primary-url=${PRIMARY_URL}" >> $GITHUB_OUTPUT

      - name: Generate consolidated summary
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          DEPLOY_ALL="${{ needs.prepare.outputs.deploy-all }}"
          DEPLOYMENT_URLS='${{ steps.gather.outputs.deployment-urls }}'
          
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## Deployment Summary
          
          ### Overview
          
          **Version**: `${{ needs.prepare.outputs.version }}`  
          **Deploy Mode**: `${{ needs.prepare.outputs.deploy-mode }}`  
          **Trigger**: `${{ inputs.trigger-type }}`
          
          EOF
          
          if [[ "$DEPLOY_ALL" == "true" ]]; then
            cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ### Production Environment
          
          EOF
            PROD_CUSTOM=$(echo "$DEPLOYMENT_URLS" | jq -r '.production.custom')
            PROD_PAGES=$(echo "$DEPLOYMENT_URLS" | jq -r '.production.pages')
            PROD_VERSION=$(echo "$DEPLOYMENT_URLS" | jq -r '.production.version')
            echo "- Custom Domain: [${PROD_CUSTOM}](${PROD_CUSTOM})" >> $GITHUB_STEP_SUMMARY
            echo "- Cloudflare Pages: [${PROD_PAGES}](${PROD_PAGES})" >> $GITHUB_STEP_SUMMARY
            echo "- Version URL: [${PROD_VERSION}](${PROD_VERSION})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ### Staging Environment
          
          EOF
            STAGING_CUSTOM=$(echo "$DEPLOYMENT_URLS" | jq -r '.staging.custom')
            STAGING_PAGES=$(echo "$DEPLOYMENT_URLS" | jq -r '.staging.pages')
            STAGING_VERSION=$(echo "$DEPLOYMENT_URLS" | jq -r '.staging.version')
            echo "- Custom Domain: [${STAGING_CUSTOM}](${STAGING_CUSTOM})" >> $GITHUB_STEP_SUMMARY
            echo "- Cloudflare Pages: [${STAGING_PAGES}](${STAGING_PAGES})" >> $GITHUB_STEP_SUMMARY
            echo "- Version URL: [${STAGING_VERSION}](${STAGING_VERSION})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ### Review Environment
          
          EOF
            REVIEW_CUSTOM=$(echo "$DEPLOYMENT_URLS" | jq -r '.review.custom')
            REVIEW_PAGES=$(echo "$DEPLOYMENT_URLS" | jq -r '.review.pages')
            REVIEW_VERSION=$(echo "$DEPLOYMENT_URLS" | jq -r '.review.version')
            echo "- Custom Domain: [${REVIEW_CUSTOM}](${REVIEW_CUSTOM})" >> $GITHUB_STEP_SUMMARY
            echo "- Cloudflare Pages: [${REVIEW_PAGES}](${REVIEW_PAGES})" >> $GITHUB_STEP_SUMMARY
            echo "- Version URL: [${REVIEW_VERSION}](${REVIEW_VERSION})" >> $GITHUB_STEP_SUMMARY
          else
            ENVIRONMENT="${{ needs.prepare.outputs.environment }}"
            ENV_NAME="${ENVIRONMENT^}"
            
            cat << EOF >> $GITHUB_STEP_SUMMARY
          ### ${ENV_NAME} Environment
          
          EOF
            ENV_CUSTOM=$(echo "$DEPLOYMENT_URLS" | jq -r ".${ENVIRONMENT}.custom")
            ENV_PAGES=$(echo "$DEPLOYMENT_URLS" | jq -r ".${ENVIRONMENT}.pages")
            ENV_VERSION=$(echo "$DEPLOYMENT_URLS" | jq -r ".${ENVIRONMENT}.version")
            echo "- Custom Domain: [${ENV_CUSTOM}](${ENV_CUSTOM})" >> $GITHUB_STEP_SUMMARY
            echo "- Cloudflare Pages: [${ENV_PAGES}](${ENV_PAGES})" >> $GITHUB_STEP_SUMMARY
            echo "- Version URL: [${ENV_VERSION}](${ENV_VERSION})" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Update GitHub Release
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.prepare.outputs.version }}';
            const deployAll = '${{ needs.prepare.outputs.deploy-all }}' === 'true';
            const environment = '${{ needs.prepare.outputs.environment }}';
            const deploymentUrls = JSON.parse('${{ steps.gather.outputs.deployment-urls }}');
            const deploymentType = '${{ inputs.trigger-type }}' === 'manual' ? 'Manual' : 'Tag-Based';
            const deployMode = '${{ needs.prepare.outputs.deploy-mode }}';
            const timestamp = new Date().toISOString().split('T')[0];
            
            try {
              let release;
              
              // Attempt to retrieve existing release
              try {
                release = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: version
                });
                core.info(`Found existing release for version ${version}`);
              } catch (error) {
                if (error.status === 404) {
                  // Create new release if it doesn't exist
                  const isPrerelease = /-(alpha|beta|rc|preview)/i.test(version);
                  release = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: version,
                    name: `Release ${version}`,
                    body: `## Release ${version}\n\n### Deployment History\n\n`,
                    draft: false,
                    prerelease: isPrerelease
                  });
                  core.info(`Created new release for version ${version}`);
                } else {
                  throw error;
                }
              }
              
              const currentBody = release.data.body || '';
              const modeIndicator = deployMode === 'static' ? ' [Static]' : '';
              let deploymentEntries = [];
              
              if (deployAll) {
                // Generate entries for all environments
                const environments = ['production', 'staging', 'review'];
                for (const env of environments) {
                  const urls = deploymentUrls[env];
                  const entry = `- **${env.charAt(0).toUpperCase() + env.slice(1)}**${modeIndicator} (${deploymentType}): [${urls.custom.replace('https://', '')}](${urls.custom}) | [Cloudflare Pages](${urls.pages}) | [Version Branch](${urls.version}) — Deployed: ${timestamp}`;
                  deploymentEntries.push(entry);
                }
              } else {
                // Single environment entry
                const urls = deploymentUrls[environment];
                const envName = environment.charAt(0).toUpperCase() + environment.slice(1);
                const entry = `- **${envName}**${modeIndicator} (${deploymentType}): [${urls.custom.replace('https://', '')}](${urls.custom}) | [Cloudflare Pages](${urls.pages}) | [Version Branch](${urls.version}) — Deployed: ${timestamp}`;
                deploymentEntries.push(entry);
              }
              
              let updatedBody = currentBody;
              
              // Update or add each deployment entry
              for (const entry of deploymentEntries) {
                const envMatch = entry.match(/\*\*(\w+)\*\*/);
                if (envMatch) {
                  const env = envMatch[1].toLowerCase();
                  const envPattern = new RegExp(`^- \\*\\*${envMatch[1]}\\*\\*.*$`, 'gm');
                  
                  if (envPattern.test(updatedBody)) {
                    // Replace existing entry for this environment
                    updatedBody = updatedBody.replace(envPattern, entry);
                  } else if (updatedBody.includes('### Deployment History')) {
                    // Add new entry under existing section
                    updatedBody = updatedBody.replace(
                      '### Deployment History\n',
                      `### Deployment History\n${entry}\n`
                    );
                  } else {
                    // Create new deployment history section
                    updatedBody = updatedBody + `\n\n### Deployment History\n${entry}\n`;
                  }
                }
              }
              
              // Update the release
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                body: updatedBody
              });
              
              if (deployAll) {
                core.info(`Updated release notes for ${version} (all environments)`);
              } else {
                core.info(`Updated release notes for ${version} (${environment} environment)`);
              }
              
              core.setOutput('release-url', release.data.html_url);
            } catch (error) {
              core.warning(`Failed to update release notes: ${error.message}`);
              core.warning('This is non-critical. Deployment was successful.');
            }

      - name: Log completion status
        run: |
          echo "::notice title=Deployment Workflow Complete::Version ${{ needs.prepare.outputs.version }} has been successfully deployed"